1. Single Responsibility Principle (Принцип единственной ответственности)
Что означает: Каждый класс или модуль должен иметь только одну причину для изменения — то есть отвечать за одну конкретную задачу.

Пример из жизни:
Представим, что у нас есть человек, который одновременно и врач, и бухгалтер. Если он заболел, ему нужно лечиться, а не заниматься бухгалтерией. Лучше разделить эти обязанности: один человек — врач, другой — бухгалтер. Так, каждый занимается своей задачей, и изменения в одной области не влияют на другую.

2. Open/Closed Principle (Принцип открытости/закрытости)
Что означает: Объекты или классы должны быть открыты для расширения, но закрыты для изменения. То есть можно добавлять новые функции, не трогая существующий код.

Пример из жизни:
Допустим, у нас есть универсальный пульт для управления техникой. Когда появляется новая техника, мы можем добавить поддержку её, не меняя сам пульт — просто подключаем новую функцию. Старый пульт работает без изменений, а новые возможности добавляются расширением.

3. Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
Что означает: Объекты наследующих классов должны быть взаимозаменяемыми с объектами базового класса без нарушения работы программы.

Пример из жизни:
Представим, что у нас есть транспортное средство — велосипед. Мы можем заменить его на мотоцикл или автомобиль, и всё равно сможем его использовать для поездки. Все эти транспортные средства должны поддерживать одинаковый интерфейс (например, возможность ехать), чтобы заменять друг друга без проблем.

4. Interface Segregation Principle (Принцип разделения интерфейсов)
Что означает: Не заставляйте клиентов зависеть от методов, которые они не используют. Лучше создавать узкоспециализированные интерфейсы.

Пример из жизни:
В магазине есть кассиры и менеджеры. Кассирам не нужны функции управления запасами, а менеджерам — не нужны функции оплаты. Поэтому лучше разделить их обязанности: кассиры — только продавать, менеджеры — управлять запасами. Каждый выполняет только свою работу.

5. Dependency Inversion Principle
Что означает:
Высокоуровневые модули (например, логика программы) не должны зависеть от деталей реализации (например, конкретных способов хранения данных). Вместо этого оба должны зависеть от абстракций (например, интерфейсов). Также, детали должны зависеть от абстракций, а не наоборот.

Объяснение своими словами:
Представим, что у нас есть устройство, которое работает с разными видами батареек: обычными или аккумуляторами. Вместо того, чтобы устройство было специально сделано под один тип батареек, оно работает с универсальным интерфейсом — например, "поддержка любого типа батареек". Тогда, если мы захотим поменять батарейки, ничего не сломается, и устройство не нужно переделывать.

Пример из жизни:
Мы покупаем зарядное устройство для телефона. Оно должно работать с разными моделями телефонов. Вместо того чтобы делать отдельное зарядное для каждого телефона, мы используем универсальный кабель или разъем, который подходит ко всем. Это — принцип инверсии зависимостей: устройство зависит не от конкретной модели телефона, а от общего стандарта.